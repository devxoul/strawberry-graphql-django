{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Strawberry GraphQL Django","text":"<p> Strawberry integration with Django.</p> <p>makes it easier to build better web apps more quickly and with less code.</p> <p> </p>"},{"location":"#supported-features","title":"Supported features:","text":"<ul> <li> GraphQL type generation from models</li> <li> Filtering, pagination and ordering</li> <li> Basic create, retrieve, update and delete (CRUD) types and mutations</li> <li> Basic Django auth support, current user query, login and logout mutations</li> <li> Django sync and async views</li> <li> Unit test integration</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install strawberry-graphql-django\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code># models.py\nfrom django.db import models\n\nclass Fruit(models.Model):\n\"\"\"A tasty treat\"\"\"\n    name = models.CharField(max_length=20)\n    color = models.ForeignKey('Color', blank=True, null=True,\n            related_name='fruits', on_delete=models.CASCADE)\n\nclass Color(models.Model):\n    name = models.CharField(\n        max_length=20,\n        help_text=\"field description\",\n    )\n</code></pre> <pre><code># types.py\nimport strawberry\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: 'Color'\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre> <pre><code># schema.py\nimport strawberry\nfrom typing import List\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n    fruits: List[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <pre><code># settings.py\nSTRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n}\n</code></pre> <p>Code above generates following schema.</p> <pre><code>\"\"\"\nA tasty treat\n\"\"\"\ntype Fruit {\n  id: ID!\n  name: String!\n  color: Color\n}\n\ntype Color {\n  id: ID!\n  \"\"\"\n  field description\n  \"\"\"\n  name: String!\n  fruits: [Fruit!]\n}\n\ntype Query {\n  fruits: [Fruit!]!\n}\n</code></pre> <pre><code># urls.py\nfrom django.urls import include, path\nfrom strawberry.django.views import AsyncGraphQLView\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre>"},{"location":"community-projects/","title":"Community projects","text":"Project Description  Strawberry-Django-plus  Additional features that are out of this project scope.  Strawberry-Django-JWT  JWT implementation with Strawberry and Django.  Strawberry-Django-Auth  Authentication System for Django using Strawberry."},{"location":"contributing/","title":"Contributing","text":"<p>We use poetry to manage dependencies, to get started follow these steps:</p> <pre><code>git clone https://github.com/strawberry-graphql/strawberry-graphql-django.git\ncd strawberry-graphql-django\npoetry install\npoetry run pytest\n</code></pre> <p>This will install all the dependencies (including dev ones) and run the tests.</p>"},{"location":"contributing/#pre-commit","title":"Pre commit","text":"<p>We have a configuration for pre-commit, to add the hook run the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"contributing/#docs-setup-and-local-server","title":"Docs setup and local server:","text":"<p>We use Material for MkDocs, you can read the documentation here</p> <pre><code>make serve-docs\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#how-to-access-django-request-object-in-resolvers","title":"How to access Django request object in resolvers?","text":"<p>The request object is accessible via the <code>info.context.request</code> object.</p> <pre><code>def resolver(root, info: Info):\n    request = info.context.request\n</code></pre>"},{"location":"faq/#how-to-access-the-current-user-object-in-resolvers","title":"How to access the current user object in resolvers?","text":"<p>The current user object is accessible via the <code>info.context.request.user</code> object.</p> <pre><code>def resolver(root, info: Info):\n    current_user = info.context.request.user\n</code></pre>"},{"location":"faq/#autocompletion-with-editors","title":"Autocompletion with editors","text":"<p>Some editors like VSCode may not be able to resolve symbols and types without explicit <code>strawberry.django</code> import. Adding following line to code fixes that problem.</p> <pre><code>import strawberry.django\n</code></pre>"},{"location":"faq/#example-project","title":"Example project?","text":"<p>See complete Django project from github repository folder examples/django.</p>"},{"location":"guides/quick-start/","title":"Strawberry GraphQL Django extension","text":"<p>This library provides a toolset for GraphQL schema generation from Django models.</p>"},{"location":"guides/quick-start/#installing-the-package","title":"Installing the package","text":"<pre><code>pip install strawberry_graphql_django\n</code></pre>"},{"location":"guides/quick-start/#sample-project","title":"Sample project","text":"<p>Your boss asks you for a Django model called <code>Fruit</code>, which has two attributes, name and color.</p> <pre><code># models.py\nfrom django.db import models\n\nclass Fruit(models.Model):\n    name = models.CharField(max_length=20)\n    color = models.CharField(max_length=20)\n</code></pre> <p>Soon after that, your boss asks you to implement an API for that model so that everyone can access our great fruit database from all over the world.</p> <p>The <code>Fruit</code> model has name and color attributes and we want to publish both of them. The GraphQL output type for our model is generated by using the <code>strawberry_django.type</code> decorator. Both fields are char fields so we will need to use the built-in Python <code>str</code> type in our API.</p> <pre><code># types.py\nimport strawberry_django\nfrom . import models\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    name: str\n    color: str\n</code></pre> <p>The last step is to generate the <code>Query</code> type and the <code>Schema</code>, which we can do using the core package <code>strawberry</code>.</p> <pre><code># schema.py\nimport strawberry\nfrom typing import List\nfrom .types import Fruit\n\n@strawberry.type\nclass Query:\n    fruits: List[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <p>Finally we add a <code>AsyncGraphQLView</code> view to our list of urls so that we can start making our first queries.</p> <pre><code># urls.py\nfrom django.urls import include, path\nfrom strawberry.django.views import AsyncGraphQLView\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre> <p>After that, once the development server is running, you can read your fruits from the database through a GraphQL request.</p> <pre><code>query {\n  fruits {\n    name\n    color\n  }\n}\n# -&gt; fruits:\u00a0[{ name: \"strawberry\", color: \"red\" }]\n</code></pre>"},{"location":"guides/quick-start/#model-relations","title":"Model Relations","text":"<p>Your boss wants the models to be more scalable. In particular, they think encoding <code>color</code> as a string is too limiting. Let's create another model called <code>Color</code> and add a foreign key relation between the <code>Fruit</code> and <code>Color</code> models.</p> <pre><code># models.py\nfrom django.db import models\n\nclass Fruit(models.Model):\n    name = models.CharField(max_length=20)\n    color = models.ForeignKey('Color', related_name='fruits', on_delete=models.CASCADE)\n\nclass Color(models.Model):\n    name = models.CharField(max_length=20)\n</code></pre> <p>We also need to add a GraphQL Type for <code>Color</code> and modify the existing <code>Fruit</code> type to reflect our changes. The <code>auto</code> field type is used for automatic type resolution. <code>strawberry_django</code> goes through all fields and resolves field types. It also generates resolvers for relation fields for you.</p> <pre><code># types.py\nimport strawberry_django\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\n\n@strawberry_django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: 'Color'\n\n@strawberry_django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre> <p>This generates the following schema:</p> <pre><code>type Color {\n  id: ID!\n  name: String!\n  fruits: [Fruit!]\n}\n\ntype Fruit {\n  id: ID!\n  name: String!\n  color: Color!\n}\n\ntype Query {\n  fruits: [Fruit!]!\n}\n</code></pre> <p>Now you can start making queries and request all fruits and their colors from the database.</p> <pre><code>query {\n  fruits {\n    name\n    color {\n      name\n    }\n  }\n}\n# -&gt; fruits:\u00a0[\n#   { name: \"strawberry\", color: { name: \"red\" } },\n#   { name: \"raspberry\", color: { name: \"yellow\" } }\n# ]\n</code></pre>"},{"location":"guides/relationships/","title":"Relationships","text":""},{"location":"guides/relationships/#tbd","title":"(TBD)","text":""},{"location":"guides/unit-testing/","title":"UnitTesting","text":""},{"location":"guides/unit-testing/#tbd","title":"(TBD)","text":""},{"location":"references/authentication/","title":"Authentication","text":"<p><code>strawberry_django</code> provides mutations to get authentication going right away. The <code>auth.register</code> mutation performs password validation using Django's <code>validate_password</code> method.</p> <pre><code># types.py\nimport strawberry\nfrom strawberry import auto\nfrom django.contrib.auth import get_user_model\n\n@strawberry.django.type(get_user_model())\nclass User:\n    username: auto\n    email: auto\n\n@strawberry.django.input(get_user_model())\nclass UserInput:\n    username: auto\n    password: auto\n\n# schema.py\nfrom strawberry.django import auth\nfrom .types import User, UserInput\n\n@strawberry.type\nclass Query:\n    me: User = auth.current_user()\n\n@strawberry.type\nclass Mutation:\n    login: User = auth.login()\n    logout = auth.logout()\n    register: User = auth.register(UserInput)\n</code></pre>"},{"location":"references/fields/","title":"Fields","text":"<p>Fields can be defined manually or <code>auto</code> type can be used for automatic type resolution. All basic field types and relation fields are supported out of the box. If you use a library that defines a custom field you will need to define an equivalent type such as <code>str</code>, <code>float</code>, <code>bool</code>, <code>int</code> or <code>id</code>.</p> <pre><code># types.py\nimport strawberry\nfrom strawberry import auto\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n\n# equivalent type, inferred by `strawberry`\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: strawberry.ID\n    name: str\n</code></pre>"},{"location":"references/fields/#relationships","title":"Relationships","text":"<p>All one-to-one, one-to-many, many-to-one and many-to-many relationship types are supported, and the many-to-many relation is described using the <code>typing.List</code> annotation. The default resolver of <code>strawberry.django.fields()</code> resolves the relationship based on given type information.</p> <pre><code># types.py\nfrom typing import List\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: 'Color'\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre>"},{"location":"references/fields/#field-customization","title":"Field customization","text":"<p>All Django types are encoded using the <code>strawberry.django.field()</code> field type by default. Fields can be customized with various parameters.</p> <pre><code># types.py\n@strawberry.django.type(models.Color)\nclass Color:\n    another_name: auto = strawberry.django.field(field_name='name')\n    internal_name: auto = strawberry.django.field(\n        name='fruits',\n        field_name='fruit_set',\n        filters=FruitFilter,\n        order=FruitOrder,\n        pagination=True,\n        description=\"A list of fruits with this color\"\n    )\n</code></pre>"},{"location":"references/fields/#overriding-the-field-class-advanced","title":"Overriding the field class (advanced)","text":"<p>If in your project, you want to change/add some of the standard <code>strawberry.django.field()</code> behaviour, it is possible to use your own custom field class when decorating a <code>strawberry.django.type</code> with the <code>field_cls</code> argument, e.g.</p> <pre><code>class CustomStrawberryDjangoField(StrawberryDjangoField):\n\"\"\"Your custom behaviour goes here.\"\"\"\n\n@strawberry_django.type(User, field_cls=CustomStrawberryDjangoField)\nclass UserType:\n    # Each of these fields will be an instance of `CustomStrawberryDjangoField`.\n    id: int\n    name: auto\n\n\n@strawberry.type\nclass UserQuery:\n    # You can directly create your custom field class on a plain strawberry type\n    user: UserType = CustomStrawberryDjangoField()\n</code></pre> <p>In this example, each of the fields of the <code>UserType</code> will be automatically created by <code>CustomStrawberryDjangoField</code>, which may implement anything from custom pagination of relationships to altering the field permissions.</p>"},{"location":"references/filters/","title":"Filtering","text":"<pre><code>import strawberry\nfrom strawberry import auto\n\n@strawberry.django.filters.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n\n@strawberry.django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n</code></pre> <p>The code above generates the following schema:</p> <pre><code>input FruitFilter {\n  id: ID\n  name: String\n}\n</code></pre>"},{"location":"references/filters/#lookups","title":"Lookups","text":"<p>Lookups can be added to all fields with <code>lookups=True</code>.</p> <pre><code>@strawberry.django.filters.filter(models.Fruit, lookups=True)\nclass FruitFilter:\n    id: auto\n    name: auto\n</code></pre> <p>Single-field lookup can be annotated with the <code>FilterLookup</code> generic type.</p> <pre><code>from strawberry.django.filters import FilterLookup\n\n@strawberry.django.filters.filter(models.Fruit)\nclass FruitFilter:\n    name: FilterLookup[str]\n</code></pre>"},{"location":"references/filters/#filtering-over-relationships","title":"Filtering over relationships","text":"<pre><code>@strawberry.django.filters.filter(models.Fruit)\nclass FruitFilter:\n    id: auto\n    name: auto\n    colors: 'ColorFilter'\n\n@strawberry.django.filters.filter(models.Color)\nclass ColorFilter:\n    id: auto\n    name: auto\n    fruits: FruitFilter\n</code></pre>"},{"location":"references/filters/#custom-filters-and-overriding-default-filtering-methods","title":"Custom filters and overriding default filtering methods","text":"<p>You can define custom filter methods and override default filter methods by defining your own resolver.</p> <pre><code>@strawberry.django.filters.filter(models.Fruit)\nclass FruitFilter:\n    is_banana: bool | None\n\n    def filter_is_banana(self, queryset):\n        if self.is_banana is None:\n            return queryset\n        if self.is_banana:\n            return queryset.filter(name='banana')\n        return queryset.exclude(name='banana')\n</code></pre>"},{"location":"references/filters/#overriding-the-default-filter-method","title":"Overriding the default <code>filter</code> method","text":"<p>For overriding the default filter logic you can provide the filter method. Note that this completely disables the default filtering, which means your custom method is responsible for handling all filter-related operations.</p> <pre><code>@strawberry.django.filters.filter(models.Fruit)\nclass FruitFilter:\n    is_apple: bool\n\n    def filter(self, queryset):\n        if self.is_apple:\n            return queryset.filter(name='apple')\n        return queryset.exclude(name='apple')\n</code></pre>"},{"location":"references/filters/#adding-filters-to-types","title":"Adding filters to types","text":"<p>All fields and mutations inherit filters from the underlying type by default.</p> <pre><code>@strawberry.django.type(models.Fruit, filters=FruitFilter)\nclass Fruit:\n    ...\n</code></pre>"},{"location":"references/filters/#adding-filters-directly-into-a-field","title":"Adding filters directly into a field","text":"<p>Filters added into a field override the default filters of this type.</p> <pre><code>@strawberry.type\nclass Query:\n    fruit: Fruit = strawberry.django.field(filters=FruitFilter)\n</code></pre>"},{"location":"references/mutations/","title":"Mutations","text":"<pre><code># schema.py\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    createFruit: Fruit = mutations.create(FruitInput)\n    createFruits: List[Fruit] = mutations.create(FruitInput)\n    updateFruits: List[Fruit] = mutations.update(FruitPartialInput)\n    deleteFruits: List[Fruit] = mutations.delete()\n\nschema = strawberry.Schema(mutation=Mutation)\n</code></pre>"},{"location":"references/mutations/#filtering","title":"Filtering","text":"<p>Filters can be added to update and delete mutations. More information in the filtering section.</p> <pre><code># schema.py\nfrom strawberry_django import mutations\n\n@strawberry.type\nclass Mutation:\n    updateFruits: List[Fruit] = mutations.update(FruitPartialInput, filters=FruitFilter)\n    deleteFruits: List[Fruit] = mutations.delete(filters=FruitFilter)\n\nschema = strawberry.Schema(mutation=Mutation)\n</code></pre>"},{"location":"references/ordering/","title":"Ordering","text":"<p>NOTE: this API may still change</p> <pre><code>@strawberry.django.ordering.order(models.Color)\nclass ColorOrder:\n    name: auto\n\n@strawberry.django.ordering.order(models.Fruit)\nclass FruitOrder:\n    name: auto\n    color: ColorOrder\n</code></pre> <p>The code above generates the following schema:</p> <pre><code>enum Ordering {\n  ASC\n  DESC\n}\n\ninput ColorOrder {\n  name: Ordering\n}\n\ninput FruitOrder {\n  name: Ordering\n  color: ColorOrder\n}\n</code></pre>"},{"location":"references/ordering/#adding-orderings-to-types","title":"Adding orderings to types","text":"<p>All fields and mutations inherit orderings from the underlying type by default.</p> <pre><code>@strawberry.django.type(models.Fruit, order=FruitOrder)\nclass Fruit:\n    ...\n</code></pre>"},{"location":"references/ordering/#adding-orderings-directly-into-a-field","title":"Adding orderings directly into a field","text":"<p>Orderings added into a field override the default filters of this type.</p> <pre><code>@strawberry.type\nclass Query:\n    fruit: Fruit = strawberry.django.field(order=FruitOrder)\n</code></pre>"},{"location":"references/pagination/","title":"Pagination","text":"<p>Currently only offset and limit type of pagination are supported.</p> <pre><code>@strawberry.django.type(models.Fruit, pagination=True)\nclass Fruit:\n    name: auto\n</code></pre> <pre><code>query {\n  fruits(pagination: { offset: 0, limit: 2 }) {\n    name\n    color\n  }\n}\n# -&gt; fruits:\u00a0[{ name: \"strawberry\", color: \"red\" }, { name: \"banana\", color: \"yellow\" }]\n</code></pre> <p>There is not default limit defined. All elements are returned if no pagination limit is defined.</p>"},{"location":"references/permissions/","title":"Permissions","text":""},{"location":"references/permissions/#tbd-not-supported-yet","title":"(TBD, not supported yet)","text":""},{"location":"references/queries/","title":"Queries","text":"<p>Queries can be written using <code>strawberry.django.field()</code> to load the fields defined in the <code>types.py</code> file.</p> <pre><code>#schema.py\n\nimport strawberry\nfrom typing import List\nfrom .types import *\n\n@strawberry.type\nclass Query:\n\n    Fruit: Fruit = strawberry.django.field()\n    Fruits: List[Fruit] = strawberry.django.field()\n\nschema = strawberry.Schema(query=Query)\n</code></pre> <p>For the single queries (like <code>Fruit</code> above), Strawberry comes with a default primary key search filter in the GraphiQL interface. The query <code>Fruits</code> gets all the objects in the Fruits by default. To query specific sets of objects a filter need to be added in the <code>types.py</code> file</p>"},{"location":"references/resolvers/","title":"Resolvers","text":"<p>Basic resolvers are generated automatically once the types are declared.</p> <p>However it is possible to override them with custom resolvers.</p>"},{"location":"references/resolvers/#sync-resolvers","title":"Sync resolvers","text":"<pre><code># types.py\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry_django.field\n    def fruits(self) -&gt; List[Fruit]:\n        return self.fruits.objects.filter(...)\n</code></pre>"},{"location":"references/resolvers/#async-resolvers","title":"Async resolvers","text":"<pre><code># types.py\nfrom strawberry import auto\nfrom typing import List\nfrom . import models\nfrom asgiref.sync import sync_to_async\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n\n    @strawberry.django.field\n    async def fruits(self) -&gt; List[Fruit]:\n        @sync_to_async\n        def query():\n            return list(self.fruits.objects.filter(...))\n        return query()\n</code></pre>"},{"location":"references/resolvers/#issues-with-resolvers","title":"Issues with Resolvers","text":"<p>It is important to note that overriding resolvers also removes default capabilities (e.g. <code>Pagination</code>, <code>Filter</code>). On your root <code>Query</code>, you can use a custom <code>get_queryset</code> to achieve similar results, but note that it will affect all root queries for that type.</p> <p>For example, if we wanted a query for berries and one for non-berry fruits, we could do the following:</p> <pre><code># types.py\nimport strawberry\nimport strawberry_django\nfrom strawberry.django import auto\nfrom typing import List\nfrom . import models\n\n@strawberry.django.type(models.Fruit, is_interface=True)\nclass Fruit:\n    id: auto\n    name: auto\n\n\n@strawberry.django.type(models.Fruit)\nclass Berry(Fruit):\n    def get_queryset(self, queryset, info):\n        return queryset.filter(name__contains=\"berry\")\n\n\n@strawberry.django.type(models.Fruit)\nclass NonBerry(Fruit):\n    def get_queryset(self, queryset, info):\n        return queryset.exclude(name__contains=\"berry\")\n\n\n@strawberry.type\nclass Query:\n    berries: List[Berry]\n    non_berries: List[NonBerry]\n</code></pre>"},{"location":"references/settings/","title":"Django Settings","text":"<p>Certain features of this library are configured using custom Django settings.</p>"},{"location":"references/settings/#strawberry_django","title":"STRAWBERRY_DJANGO","text":"<p>A dictionary with the following optional keys:</p> <ul> <li> <p><code>FIELD_DESCRIPTION_FROM_HELP_TEXT</code> (Default: <code>False</code>)</p> <p>If True, GraphQL field's description will be fetched from the corresponding Django model field's <code>help_text</code> attribute. If a description is provided using field customization, that description will be used instead.</p> </li> <li> <p><code>TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING</code> (Default: <code>False</code>)</p> <p>If True, GraphQL type descriptions will be fetched from the corresponding Django model's docstring. If a description is provided using the <code>strawberry_django.type</code> decorator, that description will be used instead.</p> </li> </ul> <p>These features can be enabled by adding this code to your <code>settings.py</code> file.</p> <pre><code>STRAWBERRY_DJANGO = {\n    \"FIELD_DESCRIPTION_FROM_HELP_TEXT\": True,\n    \"TYPE_DESCRIPTION_FROM_MODEL_DOCSTRING\": True,\n}\n</code></pre>"},{"location":"references/subscriptions/","title":"Subscriptions","text":""},{"location":"references/subscriptions/#tbd-not-supported-yet","title":"(TBD, not supported yet)","text":""},{"location":"references/types/","title":"Types","text":""},{"location":"references/types/#output-types","title":"Output types","text":"<p>Output types are generated from models. The <code>auto</code> type is used for field type auto resolution. Relational fields are described by referencing to other types generated from Django models. A many-to-many relation is described with the <code>typing.List</code> type annotation. <code>strawberry.django</code> will automatically generate resolvers for relational fields. More information about that can be read from resolvers page.</p> <pre><code>from strawberry import auto\nfrom typing import List\n\n@strawberry.django.type(models.Fruit)\nclass Fruit:\n    id: auto\n    name: auto\n    color: 'Color'\n\n@strawberry.django.type(models.Color)\nclass Color:\n    id: auto\n    name: auto\n    fruits: List[Fruit]\n</code></pre>"},{"location":"references/types/#input-types","title":"Input types","text":"<p>Input types can be generated from Django models using the <code>strawberry.django.input</code> decorator. The first parameter is the model which the type is derived from.</p> <pre><code>@strawberry.django.input(models.Fruit)\nclass FruitInput:\n    id: auto\n    name: auto\n    color: 'ColorInput'\n</code></pre> <p>A partial input type, in which all fields are optional, is generated by setting the <code>partial</code> keyword argument in <code>input</code> to <code>True</code>. Partial input types can be generated from existing input types through class inheritance.</p> <pre><code>@strawberry.django.input(models.Color, partial=True)\nclass FruitPartialInput(FruitInput):\n    color: List['ColorPartialInput']\n\n@strawberry.django.input(models.Color, partial=True)\nclass ColorPartialInput:\n    id: auto\n    name: auto\n    fruits: List[FruitPartialInput]\n</code></pre>"},{"location":"references/types/#types-from-django-models","title":"Types from Django models","text":"<p>Django models can be converted to <code>strawberry</code> Types with the <code>strawberry_django.type</code> decorator. Custom descriptions can be added using the <code>description</code> keyword argument (See: <code>strawberry.type</code> decorator API).</p> <pre><code>import strawberry\n\n@strawberry.django.type(models.Fruit, description=\"A tasty snack\")\nclass Fruit:\n    ...\n</code></pre>"},{"location":"references/types/#fields","title":"Fields","text":"<p>By default, no fields are implemented on the new type. For details on adding fields, see the Fields documentation.</p>"},{"location":"references/types/#queryset-setup","title":"<code>QuerySet</code> setup","text":"<p>By default, a <code>strawberry_django</code> type will get data from the default manager for its Django Model. You can implement a custom <code>get_queryset</code> classmethod to your type to do some extra processing to the default queryset, like filtering it further.</p> <p>Warning This function was improperly documented prior to release: <code>0.5.4</code>. Previously, the method signature was documented as: <code>get_queryset(self, queryset, info):</code> It has since changed.</p> <pre><code>@strawberry.django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info):\n        return queryset.filter(name__contains=\"berry\")\n</code></pre> <p>The <code>get_queryset</code> classmethod is given a <code>QuerySet</code> to filter and a <code>strawberry</code> <code>Info</code> object containing details about the request.</p> <p>You can use that <code>info</code> parameter to, for example, limit access to results based on the current user in the request:</p> <pre><code>@strawberry.django.type(models.Fruit)\nclass Berry:\n\n    @classmethod\n    def get_queryset(cls, queryset, info):\n        if not info.context.request.user.is_staff:\n            # Restrict access to top secret berries if the user is not a staff member\n            queryset = queryset.filter(is_top_secret=False)\n        return queryset.filter(name__contains=\"berry\")\n</code></pre>"},{"location":"references/views/","title":"View","text":"<pre><code>from django.urls path\nfrom strawberry.django.views import GraphQLView, AsyncGraphQLView\nfrom .schema import schema\n\nurlpatterns = [\n    path('graphql/sync', GraphQLView.as_view(schema=schema)),\n    path('graphql', AsyncGraphQLView.as_view(schema=schema)),\n]\n</code></pre>"}]}